% =========================================================
% Structures, Interpretations, and Variable Assignments
% =========================================================

\subsection{Semantics: Structures and Variable Assignments}

% ---------------------------------------------------------
% TOOLKIT
% ---------------------------------------------------------
\begin{tcolorbox}[colback=gray!6, colframe=gray!40, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Structures — Quick Reference}},
  fonttitle=\small\bfseries]
\small
\begin{tabular}{l l l}
\toprule
\textbf{Concept} & \textbf{Meaning} & \textbf{Detail} \\
\midrule
First-order language $\mathcal{L}$ & Signature specifying symbols & \hyperref[def:fo-language]{↓ Def} \\
Structure $\mathcal{M} = \langle D, I \rangle$ & Interpretation of $\mathcal{L}$ & \hyperref[def:structure]{↓ Def} \\
Variable assignment $s$ & Function assigning domain elements to variables & \hyperref[def:var-assign]{↓ Def} \\
Modified assignment $s[x \mapsto d]$ & Change $s$ at $x$ only & \hyperref[def:mod-assign]{↓ Def} \\
Term interpretation $\llbracket t \rrbracket_{\mathcal{M},s}$ & Semantic value of a term & \hyperref[def:term-interp]{↓ Def} \\
\bottomrule
\end{tabular}
\end{tcolorbox}

\vspace{1em}

% ---------------------------------------------------------
% First-Order Language
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (First-Order Language)}},
  fonttitle=\small\bfseries]
\label{def:fo-language}
A \emph{first-order language} $\mathcal{L}$ consists of:
\begin{itemize}
  \item a set of constant symbols,
  \item a set of function symbols, each with a specified arity, and
  \item a set of predicate symbols, each with a specified arity.
\end{itemize}
Every first-order language also includes a countable set of variables and the
logical symbols $\neg, \wedge, \vee, \rightarrow, \leftrightarrow, \forall,
\exists$, and (optionally) $=$.
\end{tcolorbox}

\begin{remark}[English reading]
A first-order language is the alphabet of a formal system. It specifies which
non-logical names are available (constants, functions, predicates) but says
nothing yet about what those names mean. Meaning is supplied by a structure.
\end{remark}

% ---------------------------------------------------------
% Structure
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Structure)}},
  fonttitle=\small\bfseries]
\label{def:structure}
Let $\mathcal{L}$ be a first-order language. A \emph{structure} (or
\emph{interpretation}) for $\mathcal{L}$ is a pair
\[
\mathcal{M} = \langle D, I \rangle,
\]
where $D$ is a nonempty set called the \emph{domain of discourse} (or
\emph{universe}), and $I$ is an interpretation function assigning:
\begin{itemize}
  \item to each constant symbol $c$: an element $I(c) \in D$,
  \item to each $n$-ary function symbol $f$: a function $I(f) : D^n \to D$,
  \item to each $n$-ary predicate symbol $P$: a relation $I(P) \subseteq D^n$.
\end{itemize}
\end{tcolorbox}

\begin{remark}[English reading]
A structure gives the language its meaning. The domain specifies the universe
of objects being reasoned about, and the interpretation function assigns each
non-logical symbol a concrete mathematical object.
\end{remark}

\begin{remark}[Nonempty domain convention]
Throughout classical first-order logic, the domain $D$ is required to be
nonempty. Without this, the inference $\forall x\,\varphi \Rightarrow
\exists x\,\varphi$ (subalternation) would fail: a universal statement is
vacuously true in an empty domain while the existential statement is false.
\end{remark}

\begin{remark}[Source note]
Some texts use the term \emph{interpretation} and others use \emph{structure};
the two are synonymous. The notation $\mathcal{M}$, $\mathfrak{A}$, or
$\mathbf{A}$ all appear in the literature.
\end{remark}

% ---------------------------------------------------------
% Variable Assignment
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Variable Assignment)}},
  fonttitle=\small\bfseries]
\label{def:var-assign}
Let $\mathcal{M} = \langle D, I \rangle$ be a structure for $\mathcal{L}$.
A \emph{variable assignment} is a function
\[
s : \mathsf{Var} \to D
\]
that assigns to each variable an element of the domain.
\end{tcolorbox}

\begin{remark}[English reading]
A structure assigns meaning to non-logical symbols; a variable assignment
assigns meaning to variables. Together they determine the truth value of every
formula in the language.
\end{remark}

% ---------------------------------------------------------
% Modified Assignment
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Modified Assignment)}},
  fonttitle=\small\bfseries]
\label{def:mod-assign}
Let $s$ be a variable assignment, $x$ a variable, and $d \in D$. The
\emph{modified assignment} $s[x \mapsto d]$ is defined by
\[
s[x \mapsto d](y) =
\begin{cases}
d & \text{if } y = x, \\
s(y) & \text{if } y \neq x.
\end{cases}
\]
\end{tcolorbox}

\begin{remark}[Consequence]
Modified assignments are the formal device for evaluating quantified formulas.
The clause $\mathcal{M}, s \models \forall x\,\varphi$ checks $\mathcal{M},
s[x \mapsto d] \models \varphi$ for every $d \in D$, testing the formula
as $x$ ranges over all domain elements.
\end{remark}

% ---------------------------------------------------------
% Term Interpretation
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Interpretation of a Term)}},
  fonttitle=\small\bfseries]
\label{def:term-interp}
The \emph{interpretation} of a term $t$ in $\mathcal{M}$ under $s$, denoted
$\llbracket t \rrbracket_{\mathcal{M},s}$, is defined recursively:
\begin{enumerate}
  \item If $t$ is a variable $x$: $\llbracket x \rrbracket_{\mathcal{M},s} = s(x)$.
  \item If $t$ is a constant $c$: $\llbracket c \rrbracket_{\mathcal{M},s} = I(c)$.
  \item If $t = f(t_1,\dots,t_n)$:
  $\llbracket f(t_1,\dots,t_n) \rrbracket_{\mathcal{M},s}
  = I(f)\bigl(\llbracket t_1 \rrbracket_{\mathcal{M},s},\dots,
  \llbracket t_n \rrbracket_{\mathcal{M},s}\bigr)$.
\end{enumerate}
\end{tcolorbox}

\begin{remark}[English reading]
This is the semantic counterpart of the recursive term definition. Each
formation rule for terms has a corresponding clause that computes a domain
element from the interpretations of its components.
\end{remark}
