% =========================================================
% Syntax of Propositional Logic
% =========================================================

\subsection{Syntax of Propositional Logic}
% ---------------------------------------------------------

\subsubsection{Propositional Variables}

\begin{definition}[Propositional Variable]
A \emph{propositional variable} (or \emph{atomic proposition}) is a symbol that
represents a statement that can be either true or false.

The set of propositional variables is denoted
\[
\mathsf{Prop} = \{P_1, P_2, P_3, \dots\}
\]
or, informally, by letters such as $P, Q, R, S, \dots$.
\end{definition}

\begin{remark}
Propositional variables are the atomic building blocks of propositional logic.
They have no internal structure and are assigned truth values directly by a
truth assignment.
\end{remark}

\subsubsection{Logical Connectives}

\begin{definition}[Logical Connectives]
The \emph{logical connectives} of propositional logic are symbols used to build
compound formulas from simpler ones. The standard connectives are:

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Symbol} & \textbf{Name} & \textbf{Arity} & \textbf{Reading} \\
\hline
$\neg$ & Negation & Unary & ``not'' \\
$\wedge$ & Conjunction & Binary & ``and'' \\
$\vee$ & Disjunction & Binary & ``or'' \\
$\rightarrow$ & Conditional (Implication) & Binary & ``if \dots\ then'' \\
$\leftrightarrow$ & Biconditional & Binary & ``if and only if'' \\
\hline
\end{tabular}
\end{center}
\end{definition}

\begin{remark}
Different authors use different symbols. Common alternatives include:
$\sim$ or $!$ for negation, $\&$ or $\cdot$ for conjunction, $|$ or $+$ for
disjunction, and $\supset$ or $\Rightarrow$ for the conditional.
\end{remark}

\subsubsection{Well-Formed Formulas}

\begin{definition}[Well-Formed Formula]
Let $\mathcal{L}$ be a propositional language with propositional variables
$\mathsf{Prop}$ and logical connectives $\neg, \wedge, \vee, \rightarrow,
\leftrightarrow$.

The set $\mathsf{WFF}_{\mathcal{L}}$ of \emph{well-formed formulas} (wffs) of
$\mathcal{L}$ is defined recursively as follows:

\begin{enumerate}
  \item \textbf{Atomic formulas.}
  Every propositional variable $P \in \mathsf{Prop}$ is a well-formed formula.

  \item \textbf{Negation.}
  If $\varphi$ is a well-formed formula, then $\neg \varphi$ is a well-formed
  formula.

  \item \textbf{Binary connectives.}
  If $\varphi$ and $\psi$ are well-formed formulas, then each of the following
  is a well-formed formula:
  \[
  (\varphi \wedge \psi), \quad
  (\varphi \vee \psi), \quad
  (\varphi \rightarrow \psi), \quad
  (\varphi \leftrightarrow \psi).
  \]

  \item \textbf{Closure.}
  No expression is a well-formed formula unless it can be obtained by finitely
  many applications of rules (1)--(3).
\end{enumerate}
\end{definition}

\begin{definition}[Atomic and Molecular Formulas]
A formula is \emph{atomic} if it is a propositional variable.

A formula is \emph{molecular} (or \emph{compound}) if it is not atomic; that is,
if it is constructed using at least one logical connective.
\end{definition}

\begin{remark}
The definition of well-formed formulas is recursive (or inductive). As a
consequence, proofs about well-formed formulas typically proceed by
\emph{structural induction} on the formation of the formula.
\end{remark}

\subsubsection{Unique Readability}

\begin{theorem}[Unique Readability]
Every well-formed formula has exactly one parsing; that is, every wff can be
constructed in exactly one way according to the recursive definition.

More precisely, for every well-formed formula $\varphi$, exactly one of the
following holds:
\begin{enumerate}
  \item $\varphi$ is a propositional variable.
  \item $\varphi = \neg\psi$ for a unique wff $\psi$.
  \item $\varphi = (\psi \circ \chi)$ for a unique binary connective $\circ$ and
        unique wffs $\psi$ and $\chi$.
\end{enumerate}
\end{theorem}

\begin{remark}
Unique readability is essential for the well-definedness of semantic evaluation.
Without it, a formula might have multiple parse trees, leading to ambiguous
truth values.

The theorem relies on the use of parentheses to disambiguate binary connectives.
Without parentheses, expressions like $P \wedge Q \vee R$ would be ambiguous.
\end{remark}

\begin{definition}[Parse Tree]
The \emph{parse tree} (or \emph{formation tree}) of a formula $\varphi$ is a
labeled tree representing the unique construction of $\varphi$ according to the
recursive definition of well-formed formulas.

\begin{itemize}
  \item Each leaf is labeled with a propositional variable.
  \item Each internal node is labeled with a connective.
  \item A node labeled $\neg$ has one child.
  \item A node labeled with a binary connective has two children.
\end{itemize}
\end{definition}

\begin{remark}
The unique readability theorem guarantees that every wff has a unique parse tree.
This justifies the use of structural induction: to prove a property holds for
all formulas, it suffices to prove it for atomic formulas and show it is
preserved by each connective.
\end{remark}

\subsubsection{Subformulas}

\begin{definition}[Subformula]
The set of \emph{subformulas} of a formula $\varphi$, denoted
$\mathrm{Sub}(\varphi)$, is defined recursively as follows:

\begin{enumerate}
  \item If $\varphi$ is atomic, then $\mathrm{Sub}(\varphi) = \{\varphi\}$.

  \item If $\varphi = \neg\psi$, then
  $\mathrm{Sub}(\varphi) = \{\varphi\} \cup \mathrm{Sub}(\psi)$.

  \item If $\varphi = (\psi \circ \chi)$ for a binary connective $\circ$, then
  $\mathrm{Sub}(\varphi) = \{\varphi\} \cup \mathrm{Sub}(\psi) \cup \mathrm{Sub}(\chi)$.
\end{enumerate}

A subformula of $\varphi$ other than $\varphi$ itself is called a \emph{proper
subformula}.
\end{definition}

\subsubsection{Formula Complexity}

\begin{definition}[Formula Depth]
The \emph{depth} (or \emph{complexity}) of a formula $\varphi$, denoted
$\mathrm{depth}(\varphi)$, is defined recursively as follows:

\begin{enumerate}
  \item If $\varphi$ is atomic, then $\mathrm{depth}(\varphi) = 0$.

  \item If $\varphi = \neg\psi$, then
  $\mathrm{depth}(\varphi) = \mathrm{depth}(\psi) + 1$.

  \item If $\varphi = (\psi \circ \chi)$ for a binary connective $\circ$, then
  \[
  \mathrm{depth}(\varphi) = \max\{\mathrm{depth}(\psi), \mathrm{depth}(\chi)\} + 1.
  \]
\end{enumerate}
\end{definition}

\begin{remark}
The depth of a formula corresponds to the height of its parse tree. It measures
the maximum nesting of connectives.
\end{remark}

\subsubsection{Precedence and Parentheses}

\begin{definition}[Operator Precedence]
The standard precedence of logical connectives (from highest to lowest) is:
\begin{enumerate}
  \item Parentheses (override all precedence)
  \item Negation ($\neg$)
  \item Conjunction ($\wedge$)
  \item Disjunction ($\vee$)
  \item Conditional ($\rightarrow$)
  \item Biconditional ($\leftrightarrow$)
\end{enumerate}
\end{definition}

\begin{remark}
When connectives have the same precedence, parentheses must be used to avoid
ambiguity. Some authors treat $\wedge$ and $\vee$ as having equal precedence;
others assign $\wedge$ higher precedence than $\vee$.

The conditional $\rightarrow$ is typically right-associative:
$P \rightarrow Q \rightarrow R$ means $P \rightarrow (Q \rightarrow R)$.
\end{remark}

\begin{example}
Using standard precedence:
\begin{itemize}
  \item $\neg P \wedge Q$ means $(\neg P) \wedge Q$, not $\neg(P \wedge Q)$.
  \item $P \vee Q \wedge R$ means $P \vee (Q \wedge R)$ if $\wedge$ has higher
        precedence than $\vee$.
  \item $P \rightarrow Q \vee R$ means $P \rightarrow (Q \vee R)$.
\end{itemize}
\end{example}

% ---------------------------------------------------------
