% =========================================================
% Syntax of Propositional Logic
% =========================================================

\subsection{Syntax of Propositional Logic}

% ---------------------------------------------------------
% TOOLKIT
% ---------------------------------------------------------
\begin{tcolorbox}[colback=gray!6, colframe=gray!40, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Syntax Toolkit — Quick Reference}},
  fonttitle=\small\bfseries]
\small
\begin{tabular}{l l l}
\toprule
\textbf{Concept} & \textbf{Meaning} & \textbf{Detail} \\
\midrule
Propositional variable & Atomic symbol with no internal structure & \hyperref[def:prop-var]{↓ Def} \\
Logical connective     & Symbol forming compound formulas & \hyperref[def:connectives]{↓ Def} \\
Well-formed formula    & Recursively constructed expression & \hyperref[def:wff]{↓ Def} \\
Unique readability     & Every wff has exactly one parse tree & \hyperref[thm:unique-read]{↓ Thm} \\
Parse tree             & Tree representation of formula structure & \hyperref[def:parse-tree]{↓ Def} \\
Subformula             & Constituents of a formula & \hyperref[def:subformula]{↓ Def} \\
Formula depth          & Nesting depth of connectives & \hyperref[def:depth]{↓ Def} \\
Operator precedence    & Disambiguation convention & \hyperref[def:precedence]{↓ Def} \\
\bottomrule
\end{tabular}
\end{tcolorbox}

\vspace{1em}

% ---------------------------------------------------------
% Propositional Variables
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Propositional Variable)}},
  fonttitle=\small\bfseries]
\label{def:prop-var}
A \emph{propositional variable} (or \emph{atomic proposition}) is a primitive
symbol representing a statement that is either true or false.

The set of all propositional variables is denoted
\[
\mathsf{Prop} = \{P_1, P_2, P_3, \dots\}
\]
or informally by letters $P, Q, R, S, \dots$
\end{tcolorbox}

\begin{remark}[English reading]
A propositional variable is the smallest meaningful unit in propositional logic.
It names a proposition — ``It is raining,'' ``The number is prime'' — but has
no further decomposable structure. Atomicity is the defining feature: unlike
predicate logic, we cannot look inside a variable and ask \emph{who} or
\emph{what} it talks about.
\end{remark}

\begin{remark}[Fully formal statement]
$\mathsf{Prop}$ is a countably infinite set of symbols, pairwise distinct.
A propositional variable is any element $P_i \in \mathsf{Prop}$.
No propositional variable is a connective, a parenthesis, or a formula built
from other symbols.
\end{remark}

\begin{remark}[Consequence for proof strategy]
Proofs about \emph{all} propositional variables are trivial base cases in
structural induction: if $\varphi \in \mathsf{Prop}$, the property holds by
the atomic case of the induction.
\end{remark}

% ---------------------------------------------------------
% Logical Connectives
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Logical Connectives)}},
  fonttitle=\small\bfseries]
\label{def:connectives}
The \emph{logical connectives} of propositional logic are:

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{cccl}
\toprule
\textbf{Symbol} & \textbf{Name} & \textbf{Arity} & \textbf{Reading} \\
\midrule
$\neg$           & Negation       & Unary  & ``not $P$'' \\
$\wedge$         & Conjunction    & Binary & ``$P$ and $Q$'' \\
$\vee$           & Disjunction    & Binary & ``$P$ or $Q$'' \\
$\rightarrow$    & Conditional    & Binary & ``if $P$ then $Q$'' \\
$\leftrightarrow$& Biconditional  & Binary & ``$P$ if and only if $Q$'' \\
\bottomrule
\end{tabular}
\end{center}
\end{tcolorbox}

\begin{remark}[English reading]
Connectives are the glue. They take propositions as input and produce
propositions as output. $\neg$ flips a truth value; binary connectives
combine two truth values into one according to a fixed truth table.
\end{remark}

\begin{remark}[Notation variants across sources]
$\sim$ or $!$ for $\neg$;\quad $\&$, $\cdot$, or $\&\&$ for $\wedge$;\quad
$|$, $+$ for $\vee$;\quad $\supset$, $\Rightarrow$ for $\rightarrow$;\quad
$\equiv$, $\Leftrightarrow$ for $\leftrightarrow$.
Bjørndahl uses $\neg, \wedge, \vee, \rightarrow$. Suppes \& Hill use similar.
Always check the source's symbol table.
\end{remark}

\begin{remark}[Logical implication]
Five connectives suffice for propositional logic, but not all are independent.
$\leftrightarrow$ is definable as $(P \rightarrow Q) \wedge (Q \rightarrow P)$;
$\rightarrow$ is definable as $\neg P \vee Q$. The standard five are chosen for
readability, not minimality.
\end{remark}

% ---------------------------------------------------------
% Well-Formed Formulas
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Well-Formed Formula)}},
  fonttitle=\small\bfseries]
\label{def:wff}
Let $\mathcal{L}$ be a propositional language. The set
$\mathsf{WFF}_{\mathcal{L}}$ of \emph{well-formed formulas} is the smallest set
satisfying:

\begin{enumerate}
  \item \textbf{Atomic:} Every $P \in \mathsf{Prop}$ is a wff.
  \item \textbf{Negation:} If $\varphi$ is a wff, so is $\neg\varphi$.
  \item \textbf{Binary:} If $\varphi, \psi$ are wffs, so are
        $(\varphi \wedge \psi)$, $(\varphi \vee \psi)$,
        $(\varphi \rightarrow \psi)$, $(\varphi \leftrightarrow \psi)$.
  \item \textbf{Closure:} Nothing else is a wff.
\end{enumerate}
\end{tcolorbox}

\begin{remark}[English reading]
A wff is any expression that can be produced by starting with atomic variables
and repeatedly applying connectives according to the rules above. The closure
clause (rule 4) is crucial: it rules out nonsense strings like
$\rightarrow P \wedge$ that no finite application of rules~1--3 can produce.
\end{remark}

\begin{remark}[Fully quantified form]
$\mathsf{WFF}$ is the intersection of all sets $X$ satisfying:
(i) $\mathsf{Prop} \subseteq X$;
(ii) $\varphi \in X \Rightarrow \neg\varphi \in X$;
(iii) $\varphi, \psi \in X \Rightarrow (\varphi \circ \psi) \in X$ for each
binary connective $\circ$.
This is the standard \emph{inductive definition} / least fixed-point construction.
\end{remark}

\begin{remark}[Consequence — structural induction]
Because $\mathsf{WFF}$ is inductively defined, \emph{structural induction}
applies: to prove property $\mathcal{P}(\varphi)$ for all wffs, prove it for
atomic $\varphi$, and show that each formation rule preserves $\mathcal{P}$.
This is the standard proof technique for syntactic results in logic.
\end{remark}

\begin{definition}[Atomic and Molecular Formulas]
A formula is \emph{atomic} if it is a propositional variable.
A formula is \emph{molecular} (or \emph{compound}) if it is not atomic.
\end{definition}

% ---------------------------------------------------------
% Unique Readability
% ---------------------------------------------------------
\begin{tcolorbox}[colback=thmbox, colframe=thmborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Theorem (Unique Readability)}},
  fonttitle=\small\bfseries]
\label{thm:unique-read}
Every well-formed formula $\varphi$ can be constructed in exactly one way.
Formally, exactly one of the following holds:
\begin{enumerate}
  \item $\varphi \in \mathsf{Prop}$ (atomic case).
  \item $\varphi = \neg\psi$ for a unique wff $\psi$.
  \item $\varphi = (\psi \circ \chi)$ for a unique binary connective $\circ$
        and unique wffs $\psi$, $\chi$.
\end{enumerate}
\end{tcolorbox}

\begin{remark}[Why this theorem is a theorem]
The recursive definition of wffs gives many ways to \emph{generate} formulas.
Unique readability asserts that no two generation paths produce the same string.
This is non-trivial: it fails for most context-free grammars. Propositional
logic avoids ambiguity by requiring explicit parentheses around every binary
connective application.
\end{remark}

\begin{remark}[Consequence — well-defined semantics]
Truth evaluation $v(\varphi)$ is defined recursively by cases on the structure
of $\varphi$. If $\varphi$ had two structures, $v(\varphi)$ might be
ill-defined. Unique readability guarantees that the recursive definition of
truth is coherent.
\end{remark}

\begin{remark}[Consequence — structural induction is safe]
Structural induction proceeds by case analysis on the unique form of $\varphi$.
Without unique readability, cases could overlap and the induction would break.
\end{remark}

% ---------------------------------------------------------
% Parse Tree
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Parse Tree)}},
  fonttitle=\small\bfseries]
\label{def:parse-tree}
The \emph{parse tree} (or \emph{formation tree}) of a wff $\varphi$ is a
labeled binary tree where:
\begin{itemize}
  \item Each \textbf{leaf} is labeled with a propositional variable.
  \item Each \textbf{internal node} is labeled with a connective.
  \item A node labeled $\neg$ has \textbf{one child}; a node labeled with a
        binary connective has \textbf{two children}.
\end{itemize}
\end{tcolorbox}

\begin{remark}[Intuition]
The parse tree externalizes the unique recursive structure of a formula. Reading
it top-down reconstructs the formula; reading it bottom-up shows how sub-results
combine into the whole truth value.
\end{remark}

\begin{remark}[Consequence]
Unique readability guarantees every wff has a unique parse tree. This makes
structural induction synonymous with tree induction: induction on the height of
the parse tree.
\end{remark}

% ---------------------------------------------------------
% Subformula
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Subformula)}},
  fonttitle=\small\bfseries]
\label{def:subformula}
The set of \emph{subformulas} of $\varphi$, written $\mathrm{Sub}(\varphi)$,
is defined recursively:
\begin{enumerate}
  \item $\varphi$ atomic: $\mathrm{Sub}(\varphi) = \{\varphi\}$.
  \item $\varphi = \neg\psi$: $\mathrm{Sub}(\varphi) = \{\varphi\} \cup \mathrm{Sub}(\psi)$.
  \item $\varphi = (\psi \circ \chi)$:
        $\mathrm{Sub}(\varphi) = \{\varphi\} \cup \mathrm{Sub}(\psi) \cup \mathrm{Sub}(\chi)$.
\end{enumerate}
A \emph{proper subformula} is any element of $\mathrm{Sub}(\varphi)$ other
than $\varphi$ itself.
\end{tcolorbox}

\begin{remark}[Intuition]
Every node in the parse tree of $\varphi$ corresponds to exactly one subformula.
The subformulas are the ``parts'' of $\varphi$ visible at each level of nesting.
\end{remark}

\begin{remark}[Consequence]
Many logical properties — tautology, satisfiability — are defined on
whole formulas but proved by induction on subformulas. A property that holds
for all subformulas of $\varphi$ and is preserved by connectives holds for
$\varphi$.
\end{remark}

% ---------------------------------------------------------
% Formula Depth
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Formula Depth)}},
  fonttitle=\small\bfseries]
\label{def:depth}
The \emph{depth} (or \emph{complexity}) of a formula $\varphi$:
\begin{enumerate}
  \item $\varphi$ atomic: $\mathrm{depth}(\varphi) = 0$.
  \item $\varphi = \neg\psi$: $\mathrm{depth}(\varphi) = \mathrm{depth}(\psi) + 1$.
  \item $\varphi = (\psi \circ \chi)$:
        $\mathrm{depth}(\varphi) = \max\{\mathrm{depth}(\psi),\, \mathrm{depth}(\chi)\} + 1$.
\end{enumerate}
\end{tcolorbox}

\begin{remark}[Intuition]
Depth measures how deeply nested the connectives are — equivalently, the height
of the parse tree. A depth-0 formula has no connectives; a depth-$n$ formula
has a subformula at nesting level $n$.
\end{remark}

\begin{remark}[Consequence — strong induction]
Induction on depth is the canonical way to prove properties of all wffs when
you need the inductive hypothesis to apply to all formulas of \emph{strictly
smaller} depth, not just immediate subformulas.
\end{remark}

% ---------------------------------------------------------
% Precedence
% ---------------------------------------------------------
\begin{tcolorbox}[colback=propbox, colframe=propborder, arc=2pt,
  left=6pt, right=6pt, top=4pt, bottom=4pt,
  title={\small\textbf{Definition (Operator Precedence)}},
  fonttitle=\small\bfseries]
\label{def:precedence}
Standard precedence (highest binds tightest):
\begin{enumerate}
  \item Parentheses (override all)
  \item $\neg$ (negation)
  \item $\wedge$ (conjunction)
  \item $\vee$ (disjunction)
  \item $\rightarrow$ (conditional, right-associative)
  \item $\leftrightarrow$ (biconditional)
\end{enumerate}
\end{tcolorbox}

\begin{remark}[English reading]
Precedence is a convention for omitting parentheses without creating ambiguity.
$\neg P \wedge Q$ means $(\neg P) \wedge Q$ because $\neg$ binds tighter than
$\wedge$. The conditional is right-associative: $P \rightarrow Q \rightarrow R$
means $P \rightarrow (Q \rightarrow R)$.
\end{remark}

\begin{remark}[Common error]
$\neg P \wedge Q$ is \emph{not} $\neg(P \wedge Q)$. Negation applies to the
smallest formula immediately to its right. When in doubt, use explicit
parentheses.
\end{remark}

\begin{example}
Using standard precedence:
\begin{itemize}
  \item $\neg P \wedge Q$ means $(\neg P) \wedge Q$.
  \item $P \vee Q \wedge R$ means $P \vee (Q \wedge R)$ if $\wedge > \vee$.
  \item $P \rightarrow Q \vee R$ means $P \rightarrow (Q \vee R)$.
\end{itemize}
\end{example}
