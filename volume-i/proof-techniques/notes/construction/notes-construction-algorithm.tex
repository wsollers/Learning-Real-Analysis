% =========================================================
% Proof Construction Algorithm
% (Preserved from original proof-techniques notes)
% =========================================================

\begin{remark}[Purpose of this section]
This section records a general proof-writing procedure intended
to be applied consciously until it becomes internalized.
It answers the question: once the architecture is chosen
(Section~\ref{sec:proof-architecture}), how is the argument
executed line by line?
\end{remark}

\paragraph{Step 0: Classify the Statement.}

Determine the logical form of the claim. Common forms include:
\begin{itemize}
  \item Universal: $\forall x\; P(x)$
  \item Conditional: $P \rightarrow Q$
  \item Biconditional: $P \leftrightarrow Q$
  \item Existential: $\exists x\; P(x)$
  \item Equality: $X = Y$
  \item Set equality: $A = B$
  \item Structural: ``$R$ is an equivalence relation'',
    ``$f$ is injective''
\end{itemize}
The logical form determines the overall structure of the proof.

\paragraph{Step 1: Restate the Givens.}

Explicitly record what is given. Introduce all sets, relations,
and functions, and note any structural properties assumed.

\begin{quote}
Let $A$ be a set and let $R$ be an equivalence relation on $A$.
\end{quote}

This licenses later use of reflexivity, symmetry, and transitivity
without reintroducing them each time.

\paragraph{Step 2: Identify Objects and Their Types.}

Before reasoning begins, identify the \emph{type} of each object:
is it an element, a set, a function, or a relation?
What is its ambient universe?

\[
x \in A,\quad f : A \to B,\quad R \subseteq A \times A.
\]

Many logical errors arise from confusing equality, membership,
and inclusion. Every object used in a proof must have a declared type.

\paragraph{Step 3: Introduce Arbitrary Elements.}

If the claim is universal, immediately introduce arbitrary elements.

\[
\text{Let } a, b \in A \text{ be arbitrary.}
\]

This step enables general reasoning and avoids illegal specialization.

\paragraph{Step 4: Expand the Goal.}

Rewrite the conclusion using definitions rather than named concepts.
\begin{itemize}
  \item To prove $f$ injective: expand the definition of injectivity.
  \item To prove $A = B$: prove $A \subseteq B$ and $B \subseteq A$.
  \item To prove $x \in A \cup B$: rewrite as $x \in A \lor x \in B$.
\end{itemize}
Never attempt to prove a named concept directly without first
expanding its definition.

\paragraph{Step 5: Introduce Helper Objects.}

Introduce auxiliary objects needed for the argument: witnesses,
intermediate elements, bounds, images under functions.

\[
\text{Let } x \in A,\quad
\text{let } P_a \text{ be the block containing } a,\quad
\text{let } b := f(a).
\]

No object should appear in a proof without being explicitly introduced.

\paragraph{Step 6: Apply One Definition or Property at a Time.}

Each step follows from exactly one of:
\begin{itemize}
  \item a definition,
  \item a hypothesis,
  \item a previously proved theorem,
  \item a basic logical rule.
\end{itemize}

If progress stalls, identify which definition has not yet been unpacked.

\paragraph{Step 7: Use Forward and Backward Reasoning.}

Proofs often alternate between two modes:
\begin{itemize}
  \item \emph{Forward}: deduce consequences from the hypotheses.
  \item \emph{Backward}: rewrite the goal to determine what
    would suffice to prove it.
\end{itemize}
Backward reasoning is effective when the conclusion involves
nested definitions.

\paragraph{Step 8: Handle Cases Explicitly.}

If a statement splits into cases, enumerate and exhaust all of them.

\[
\text{Either } x \in A \text{ or } x \notin A.
\]

Each case is treated separately; together they cover all possibilities.

\paragraph{Step 9: Close the Argument.}

Once the desired conclusion is reached, state it explicitly.
\begin{itemize}
  \item ``Thus $x \in B$, so $A \subseteq B$.''
  \item ``Hence $f$ is injective.''
  \item ``Therefore the two sets are equal.''
\end{itemize}

\paragraph{Step 10: Signal Completion.}

Conclude with $\qed$ or an explicit statement that the proof is complete.

\bigskip

\paragraph{Legal Moves.}

\begin{itemize}
  \item An existential witness may not be chosen before existence is proved.
  \item An arbitrary element may only be introduced under universal scope.
  \item The conclusion may never be assumed.
  \item Definitions must be applied in full, not partially.
\end{itemize}

\paragraph{Line-by-Line Discipline.}

For each line, silently check:
\begin{enumerate}[label=(\roman*)]
  \item Has every object in this line been defined?
  \item Which definition, hypothesis, or theorem justifies this step?
  \item Does this step move the argument closer to the stated goal?
\end{enumerate}

\paragraph{Stop Conditions.}

A proof is complete when:
\begin{itemize}
  \item a universal claim has been shown for an arbitrary element;
  \item an existential claim has produced a valid witness;
  \item a set equality has established both inclusions;
  \item each direction of a biconditional has been proved.
\end{itemize}

\begin{remark}[On internalizing the algorithm]
This procedure is intentionally explicit and mechanical.
With practice, these steps become automatic and are applied
subconsciously. Experienced mathematicians follow the same process
but omit intermediate steps once correctness is assured.
Until fluency is achieved, longer proofs with explicit steps
are preferable to shorter proofs with implicit gaps.
\end{remark}
